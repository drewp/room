#!/usr/bin/python

"""
watch for bluetooth devices

this discoverer finds me if my treo has its screen on only, so I
have to wake up my own treo for a few seconds. 

I can use 'hcitool cc <addr> && hcitool rssi <addr>' to wake it up and
get its signal strength, but that pattern crashes my treo easily. I
still don't have an access that wakes up the treo and then doesn't
crash it. Maybe I could pretend to be a headset or something.

depends on ubuntu package: python-bluez

"""

import bluetooth, logging, time
from twisted.internet import reactor, defer
import hubclient
from louie import dispatcher
from logsetup import commonlogsetup
from rdflib.Graph import Graph
from rdflib import Literal, Variable, Namespace

log = commonlogsetup(filename=None)
log.setLevel(logging.INFO)

ROOM = Namespace("http://projects.bigasterisk.com/room/")

class Disco(bluetooth.DeviceDiscoverer):
    # it might be cool if this somehow returned
    # _bt.EVT_INQUIRY_RESULT_WITH_RSSI: results. see
    # /usr/share/pycentral/python-bluez/site-packages/bluetooth.py
    def device_discovered(self, address, device_class, name):
        log.debug("seeing: %s - %s (class 0x%X)" % (address, name, device_class))
        self.nearby.append((address, name))

    def inquiry_complete(self):
        pass
    
    def process_inquiry(self):
        # more async version of the normal method
        """
        Starts calling process_event, returning a deferred that fires
        when we're done.
        """
        self.done_inquiry = defer.Deferred()
        
        if self.is_inquiring or len(self.names_to_find) > 0:
            self.keep_processing()
        else:
            self.done_inquiry.callback(None)

        return self.done_inquiry

    def keep_processing(self):
        # this one still blocks "a little bit"
        if self.is_inquiring or len(self.names_to_find) > 0:
            reactor.callLater(0, self.keep_processing)
            self.process_event() # <-- blocks here
        else:
            self.done_inquiry.callback(None)

    def nearbyDevices(self):
        """deferred to list of (addr,name) pairs"""
        self.nearby = []
        self.find_devices()
        d = self.process_inquiry()
        d.addCallback(lambda result: self.nearby)
        return d

def devicesFromAddress(address):
    for row in graph.query(
        "SELECT ?dev { ?dev rm:bluetoothAddress ?addr }",
        initNs=dict(rm=ROOM),
        initBindings={Variable("?addr") : Literal(address)}):
        (dev,) = row
        yield dev
                              
hubclient.connect()

graph = Graph()
graph.parse("phones.n3", format="n3")

d = Disco()

lastDevs = set()
def loop(*args):
    devs = d.nearbyDevices()

    def compare(newDevs):
        global lastDevs
        lostDevs = lastDevs.copy()
        prevDevs = lastDevs.copy()
        lastDevs.clear()
        for address, name in newDevs:
            if address not in prevDevs:
                matches = 0
                for dev in devicesFromAddress(address):
                    log.info("found %s" % dev)
                    matches += 1
                    dispatcher.send((str(ROOM['bluetooth']),
                                     str(ROOM['senses']),
                                     None),
                                    obj=str(dev))
                if not matches:
                    log.info("no matches for %s (%s)" % (name, address))
                    f = open("bluetooth-stray-phones", "a")
                    print >>f, "%s %s %s" % (time.time(), name, address)
                    f.close()
                    
            lostDevs.discard(address)
            lastDevs.add(address)

        for address in lostDevs:
            for dev in devicesFromAddress(address):
                log.info("lost %s" % dev)
                dispatcher.send((str(ROOM['bluetooth']), str(ROOM['senses']),
                                 None), obj=str(dev), delete=True)

        reactor.callLater(0, loop)
    devs.addCallback(compare)
    devs.addErrback(log.error)


reactor.callLater(0, loop)

reactor.run()
