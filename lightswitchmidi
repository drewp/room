#!/usr/bin/python


# pyalsamidi at http://infohost.nmt.edu/~dbaird/software/

# almost related: http://lists.w3.org/Archives/Public/www-archive/2001Nov/0033


"""
n3->rdf convertor at http://www.w3.org/DesignIssues/Notation3.html

for n3 and querying, i should probably switch to librdf

my original n3, which rdflib can't parse:

@prefix : <http://projects.bigasterisk.com/room>.
@prefix lights: <http://projects.bigasterisk.com/room/lights>.
@prefix midi: <http://projects.bigasterisk.com/midi>.
cmd1 midi:notes "60 65"; :triggers <dark>.
<dark> :lightLevel [:light lights:couchleft; :to "0"], 
                   [:light lights:couchright; :to "0"].
"""


import os, select, time, xmlrpclib, socket
from twisted.internet import reactor, tksupport, defer
from pyalsamidi import pyalsamidi as amidi
import RDF

class NoteCode:
    def __init__(self):
        self.phrase = []
        self.last_note_time = 0
        self.connect()

        #self.action([67,60])

    def connect(self):
        self.light_server = xmlrpclib.ServerProxy("http://dot:%s" %
                              socket.getservbyname("lights","tcp"))

    def event(self,ev):
        if ev.data.__class__ != amidi.MidiEvent.NoteOn:
            return

        now = time.time()
        if now - self.last_note_time > .5:
            self.phrase[:] = []

        self.last_note_time = now
        self.phrase.append(ev.data.note)
        
        matched = self.action(self.phrase)
        if matched:
            self.phrase[:] = []

    def set_lights(self, lev, names):
        for n in names:
            try:
                print n,"to",lev
                self.light_server.setLight(n,lev)
            except xmlrpclib.Fault, e:
                print e, "on command setLight(%r,%r)" % (n,lev)
                self.connect()

    def action(self, phrase):
        prefixes = """
            PREFIX midi: <http://projects.bigasterisk.com/midi/>
            PREFIX room: <http://projects.bigasterisk.com/room/>
        """
        model = RDF.Model(RDF.MemoryStorage())
        u = RDF.Uri("file:/my/proj/room/midicodes.n3")
        try:
            for s in RDF.Parser('turtle').parse_as_stream(u):
                model.add_statement(s)
        except (Exception, ), e:
            # e.__class__.__module__ is "RDF", not the real module!
            if e.__class__.__name__ != "RedlandError":
                raise
            print "Error parsing %s: %s" % (u, e)
            return

        phrase_literal = RDF.Node(" ".join(map(str, phrase)))
        phrase_quoted_literal = '"%s"' % phrase_literal #?
        for res in RDF.SPARQLQuery('''
            %s
            SELECT ?action
            WHERE {
                [midi:notes %s; room:triggers ?action] .
            }''' % (prefixes, phrase_quoted_literal)).execute(model):
            print "running action %s" % res['action'].uri

            for res in RDF.SPARQLQuery('''
            %s
            SELECT ?light ?level
            WHERE {
                <%s> room:lightLevel [room:light ?light; room:to ?level] .
            }''' % (prefixes, res['action'].uri)).execute(model):
                self.do_lightlevel(res['light'].uri, res['level'])

    def do_lightlevel(self, light_uri, level):
        prefix = "http://projects.bigasterisk.com/room/lights/"
        lightname = str(light_uri)[len(prefix):]

        assert (level.literal_value['datatype'] ==
                RDF.Uri("http://www.w3.org/2001/XMLSchema#float"))
        level = float(level.literal_value['string'])

        print "light %s to level %s" % (lightname, level)
        self.set_lights(level, [lightname])
            
seq = amidi.Sequencer('Test Sequencer')
inp = seq.create_midiin('Test Midi In')

outp = seq.create_midiout('Test Midi Out')
queue = seq.create_queue()
ppq = 120
queue.set_bpm(120, ppq)
queue.start()

# If you do not have a musical keyboard connected to 64:0, you might
# need to modify this line:
os.system('aconnect -t %d 64:0 %d:%d' % (queue.id, seq.id, inp.id))
os.system('aconnect -t %d %d:%d 64:0' % (queue.id, seq.id, outp.id))

nc = NoteCode()

while 1:
    a, _, _ = select.select([inp], [], [], .1)
    while (inp in a) or inp.events_pending():
        a = []
        ev = inp.read_event()
        nc.event(ev)
