#!/usr/bin/python
"""
gather subgraphs from various services, run them through a rules
engine, and make http requests with the conclusions.

E.g. 'when drew's phone is near the house, and someone is awake,
unlock the door when the door's motion sensor is activated'

When do we gather? The services should be able to trigger us, perhaps
with PSHB, that their graph has changed.
"""


from twisted.internet import reactor
import hubclient
import time, socket, logging, re, sys
from louie import dispatcher
from rdflib.Graph import Graph, ConjunctiveGraph
from rdflib import Literal, Variable, Namespace, URIRef, StringInputSource
import restkit
from logsetup import commonlogsetup

sys.path.append("/my/proj/room/fuxi/build/lib.linux-x86_64-2.6")
from FuXi.Rete.Util import generateTokenSet
from FuXi.Rete import ReteNetwork
from rdflib import plugin
from rdflib.store import Store
from FuXi.Rete.RuleStore import N3RuleStore

log = commonlogsetup(filename=None)
log.setLevel(logging.INFO)
ROOM = Namespace("http://projects.bigasterisk.com/room/")


def anyEvent(signal, **kw):
    if not (isinstance(signal, tuple) and len(signal) == 3):
        return

    s, p = URIRef(signal[0]), URIRef(signal[1])
    if str(kw['obj']).startswith('http:'):
        o = URIRef(kw['obj'])
    else:
        o = Literal(kw['obj'])

    consider((s,p,o), kw.get('delete', False))


def consider((s,p,o), delete=False):
    """
    this is where the reasoning would go, taking all the known stmts
    and producing some more that the output modules would care about
    """

    
#hubclient.connect()
#dispatcher.connect(anyEvent)
#reactor.run()


def infer(graph, rules):
    """
    returns new graph of inferred statements
    """
    # based on fuxi/tools/rdfpipe.py
    store = plugin.get('IOMemory',Store)()        
    store.open('')

    target = Graph()
    tokenSet = generateTokenSet(graph)
    network = ReteNetwork(rules, inferredTarget=target)
    network.feedFactsToAdd(tokenSet)

    store.rollback()
    return target

def loadRules(rulesN3):
    ruleStore = N3RuleStore()
    ruleGraph = Graph(ruleStore)
    ruleGraph.parse(StringInputSource(rulesN3), format='n3')             
    return ruleStore

def parseTrig(trig):
    """
    yields quads
    """
    m = re.match(r"<([^>]+)> \{(.*)\}\s*$", trig, re.DOTALL)
    if m is None:
        raise NotImplementedError("trig format was too tricky")
        
    ctx = m.group(1)
    n3 = m.group(2)
    g = Graph()
    g.parse(StringInputSource(n3), format="n3")
    for stmt in g:
        yield stmt + (ctx,)

def addTrig(graph, url):
    trig = restkit.request(url).body_string()
    graph.addN(parseTrig(trig))

def gatherGraph():
    g = ConjunctiveGraph()
    for source in ["http://bang:9069/graph", "http://bang:9070/graph"]:
        addTrig(g, source)

    rules = loadRules('''
@prefix : <http://projects.bigasterisk.com/room/>.
@prefix bigast: <http://bigasterisk.com/>.
@prefix dev: <http://projects.bigasterisk.com/device/>.
@prefix foaf: <http://xmlns.com/foaf/0.1/> .

{ <http://bigasterisk.com/wifiDevice/00:> :connected bigast:wifiAccessPoints . } => { :auth :near :home } .
{ <http://bigasterisk.com/wifiDevice/00:> :connected bigast:wifiAccessPoints . } => { :auth :near :home } .

{
  :auth :near :home .
  dev:theaterDoorOutsideMotion :state :motion.
  dev:theaterDoorOpen :state :closed .
} => { :door :is :open } .
    ''')

    inferred = infer(g, rules)
        
    print inferred.serialize(format='n3')

gatherGraph()
