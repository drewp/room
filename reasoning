#!/usr/bin/python
"""
gather subgraphs from various services, run them through a rules
engine, and make http requests with the conclusions.

E.g. 'when drew's phone is near the house, and someone is awake,
unlock the door when the door's motion sensor is activated'

When do we gather? The services should be able to trigger us, perhaps
with PSHB, that their graph has changed.
"""


from twisted.internet import reactor, task
import time, logging, re, sys, jsonlib, datetime
from rdflib.Graph import Graph, ConjunctiveGraph
from rdflib import Namespace, URIRef, StringInputSource, Literal
import restkit
from logsetup import commonlogsetup

sys.path.append("/my/proj/room/fuxi/build/lib.linux-x86_64-2.6")
from FuXi.Rete.Util import generateTokenSet
from FuXi.Rete import ReteNetwork
from rdflib import plugin
from rdflib.store import Store
from FuXi.Rete.RuleStore import N3RuleStore

import cyclone.web

log = commonlogsetup(filename=None)
log.setLevel(logging.INFO)
logging.getLogger('restkit.client').setLevel(logging.WARN)
ROOM = Namespace("http://projects.bigasterisk.com/room/")
DEV = Namespace("http://projects.bigasterisk.com/device/")

 
def infer(graph, rules):
    """
    returns new graph of inferred statements
    """
    # based on fuxi/tools/rdfpipe.py
    store = plugin.get('IOMemory',Store)()        
    store.open('')

    target = Graph()
    tokenSet = generateTokenSet(graph)
    network = ReteNetwork(rules, inferredTarget=target)
    network.feedFactsToAdd(tokenSet)

    store.rollback()
    return target

def parseTrig(trig):
    """
    yields quads
    """
    m = re.match(r"<([^>]+)> \{(.*)\}\s*$", trig, re.DOTALL)
    if m is None:
        raise NotImplementedError("trig format was too tricky")
        
    ctx = m.group(1)
    n3 = m.group(2)
    g = Graph()
    g.parse(StringInputSource(n3), format="n3")
    for stmt in g:
        yield stmt + (ctx,)

def addTrig(graph, url):
    trig = restkit.request(url).body_string()
    graph.addN(parseTrig(trig))

def gatherGraph():
    g = ConjunctiveGraph()
    for source in ["http://bang:9069/graph", "http://bang:9070/graph"]:
        addTrig(g, source)

    ctx = ROOM.clock
    g.addN([
        (ROOM.localHour, ROOM.state, Literal(datetime.datetime.now().hour),
         ctx),
        ])
    return g

def graphWithoutMetadata(g, ignorePredicates=[]):
    """
    graph filter that removes any statements whose subjects are
    contexts in the graph and also any statements with the given
    predicates
    """
    ctxs = map(URIRef, set(g.contexts())) # weird they turned to strings

    out = ConjunctiveGraph()
    for stmt in g.quads((None, None, None)):
        if stmt[0] not in ctxs and stmt[1] not in ignorePredicates:
            out.addN([stmt])
    return out

def graphEqual(a, b, ignorePredicates=[]):
    """
    compare graphs, omitting any metadata statements about contexts
    (especially modification times) and also any statements using the
    given predicates
    """
    stmtsA = graphWithoutMetadata(a, ignorePredicates)
    stmtsB = graphWithoutMetadata(b, ignorePredicates)
    return set(stmtsA) == set(stmtsB)    

class Reasoning(object):
    def __init__(self):
        self.prevGraph = None

        self.deviceGraph = Graph()
        self.deviceGraph.parse("/my/proj/room/devices.n3", format="n3")

        self.rulesN3 = "(not read yet)"
        self.inferred = Graph() # gets replaced in each graphChanged call

    def readRules(self):
        self.rulesN3 = open('rules.n3').read() # for web display
        self.ruleStore = N3RuleStore()
        self.ruleGraph = Graph(self.ruleStore)
        self.ruleGraph.parse('rules.n3', format='n3') # for inference

    def poll(self):
        try:
            self._poll()
        except Exception, e:
            log.error(e)
            
    def _poll(self):
        g = gatherGraph()
        if (self.prevGraph is not None and
            graphEqual(g, self.prevGraph,
                       ignorePredicates=[ROOM.signalStrength])):
            return
        self.prevGraph = g
        self.graphChanged(g)

    def graphChanged(self, g):
        # i guess these are getting consumed each inference
        self.readRules()
        self.inferred = infer(g, self.ruleStore)

        print "new inferred graph:"
        for stmt in self.inferred:
            print " ", stmt

        for dev in [DEV.theaterDoorLock]:
            url = self.deviceGraph.value(dev, ROOM.putUrl)
            value = "1" if (dev, ROOM.state, ROOM.unlocked) in self.inferred else "0"
            print "put %s to %s" % (value, url)
            restkit.request(url=url+"/mode", method="PUT", body="output")
            restkit.request(url=url, method="PUT", body=value)


class Index(cyclone.web.RequestHandler):
    def get(self):
        self.set_header("Content-Type", "application/xhtml+xml")
        self.write(open('reasoning.html').read())

# for reuse
class GraphResource(cyclone.web.RequestHandler):
    def get(self, which):
        self.set_header("Content-Type", "application/json")
        r = self.settings.reasoning
        g = {'lastInput': r.prevGraph,
             'lastOutput': r.inferred,
             }[which]
        self.write(self.jsonRdf(g))

    def jsonRdf(self, g):
        return jsonlib.dumps(sorted(list(g)))

class Rules(cyclone.web.RequestHandler):
    def get(self):
        self.set_header("Content-Type", "text/plain")
        self.write(self.settings.reasoning.rulesN3)

class Application(cyclone.web.Application):
    def __init__(self, reasoning):
        handlers = [
            (r"/", Index),
            (r'/(lastInput|lastOutput)Graph', GraphResource),
            (r'/rules', Rules),
        ]
        cyclone.web.Application.__init__(self, handlers, reasoning=reasoning)

if __name__ == '__main__':
    r = Reasoning()
    import twisted.python.log
    twisted.python.log.startLogging(sys.stdout)
    
    task.LoopingCall(r.poll).start(1.0)
    reactor.listenTCP(9071, Application(r))
    reactor.run()
